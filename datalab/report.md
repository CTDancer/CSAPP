# DataLab Report
## P1 bitNor
### 题目 
```
只用~和& 实现 ~(x|y)
```
### 样例
``` 
bitNor(4, 5) = -6
```
#### 可用操作符：~ &

#### 操作符最大数量：8

#### 操作符实际使用数量：3

``` C
int bitNor(int x, int y) {
	return (~x) & (~y);
}
```
### 思路
    由德摩根定律：~(x|y) = (~x) & (~y)
---
## P2 tmax
### 题目
    返回二补码整数的最大值(0x7fffffff)

#### 可用操作符：! ~ & ^ | + << >>

#### 操作符最大数量：4

#### 操作符实际使用数量：2

```C
int tmax(void) {
	return ~(0x1 << 31);
}
```
### 思路
    ~Tmax == 0x80000000 == 0x1 << 31
---
## P3 isTmin
### 题目
    如果是二补码的最小值，则返回1，否则返回0
#### 可用操作符：! ~ & ^ | +

#### 操作符最大数量：10

#### 操作符实际使用数量：4
```C
int isTmin(int x) {
	return !((x^(~x+1)) | !x);
}
```
### 思路
    观察Tmin = 0x80000000的特性：
    1. Tmin << 1 == 0 
    2. ~Tmin + 1 == Tmin
    
    注意不能用第一种方法：这个是未定义的行为。
    编译器不必考虑溢出的把最高位舍弃，认为只有当x==0的时候才成立，所以优化成x==0
    
    但是，要注意0x0也都满足这两个特性，只需排除0x0即可
    这里用第一种特性解决，因为用的操作数少
    由于不能用<<，所以用x+x代替左移1位
---
## P4 minusOne
### 题目
    返回-1
#### 可用操作符：! ~ & ^ | + << >>

#### 操作符最大数量：2

#### 操作符实际使用数量：1
```C
int minusOne(void){
	return ~0x0;
}
```
### 思路
    观察到 -1 == 0xffffffff
    可想到 ~0x0 == -1
---
## P5 absVal
### 题目
    返回一个整数的绝对值
#### 可用操作符：! ~ & ^ | + << >>

#### 操作符最大数量：6

#### 操作符实际使用数量：5
```C
int absVal(int x){
  int sign = x >> 31;
  return (sign ^ x) + (~sign + 1);
}
```
### 思路
    如果一个数是负数，那么它的绝对值是取反+1
    如果一个数是正数，那么它的绝对值是它本身
    所以关键在于判断正负，而正负数的区别在于：
    1. 负数的符号位是1，右移31位将得到0xffffffff
    2. 正数的符号位是0，右移31位将得到0x00000000
    一个全1，一个全0，可以想到利用^:
    1. 0xffffffff ^ x = ~x
    2. 0x00000000 ^ x = x
    最后，利用符号位，负数的时候已经有~x，正数的时候已经有x，那么一个加1，一个加0即可
---
## P6 leastBitPos
### 题目
    生成掩码，只保留x的最低位1
### 样例
    leastBitPos(12) = 4
#### 可用操作符：! ~ & ^ | + << >>

#### 操作符最大数量：6

#### 操作符实际使用数量：3
```C
int leastBitPos(int x) {
	return (~x + 1) & x;
}
```
### 思路
    要得到这样的掩码，要做到2点：
    1. 最低的那个1要保留
    2. 那个1左右两边的所有数都要是0
    要把大量数都变为0的操作基本就是~
    在进行取反后，可以发现，最低位1右边的0都变成了1，而自己变成了0
    要把右边的1都变成0，则+1即可，最低位的1也因为进位变为1
    所以(~x+1) & x 就得到掩码
---
## P7 byteSwap
### 题目
    交换第n个字节和第m个字节
### 样例
    byteSwap(0x12345678, 1, 3) = 0x56341278
#### 可用操作符：! ~ & ^ | + << >>

#### 操作符最大数量：20

#### 操作符实际使用数量：16
```C
int byteSwap(int x, int n, int m){
  int move1 = n << 3; 
  int move2 = m << 3;
  int mask = 0xff;
  int p = (x >> move1 & mask) << move2;
  int q = (x >> move2 & mask) << move1;
  return p | q | (x & ~(mask << move1) & ~(mask << move2));
}
```
### 思路
    要交换两个字节，通过基本的掩码和移位即可，分别得到p 和 q
    然而现在的问题是 虽然现在把两个字节移到对应的位置上，但x那些位置上原来的数还在
    所以要利用掩码把原来的那些位置上的数全部用0盖住，得到新的x
    接下来一个自然的想法是将p q x三者直接加起来，毕竟x上面p、q原来的位置都已经变为0了
    但一个问题是如果p q在同一个位置，也就是m = n的情况，相加会进位
    所以用 | 可以避免这个问题
---
## P8 logicalShift
### 题目
    实现逻辑右移
### 样例
    logicalShift(0x87654321,4) = 0x08765432
#### 可用操作符：! ~ & ^ | + << >>

#### 操作符最大数量：20

#### 操作符实际使用数量：8

```C
int logicalShift(int x, int n) {
  int mask = (~0)+(1<<(32+~n)<<1);
  return (x>>n) & mask;
}
```
### 思路
    实现逻辑右移本质上是把右移后多出现的1给mask掉。
    掩码的生成的方法是将1向左移动32-n位，然后-1即可
    为了避免移动32位，我们把最后移动的一位单独移动就行了
---
## P9 isLessOrEqual
### 题目
    如果x<=y，返回1，否则返回0
### 样例
    isLessOrEqual(4,5) = 1
#### 可用操作符：! ~ & ^ | + << >>

#### 操作符最大数量：24

#### 操作符实际使用数量：15

```C
int logicalShift(int x, int n) {
  int delta = y + (~x+1);
  int sign_x = x >> 31;
  int sign_y = y >> 31;
  int dif = ~sign_x + sign_y;
  // x < 0 && y > 0: dif = 0;
  // x < 0 && y < 0: dif = -1;
  // x > 0 && y < 0: dif = -2;
  // x > 0 && y > 0: dif = -1;
  return (~(dif+1 >> 31) & !(delta >> 31)) | (!dif);
}
```
### 思路
    要看小于等于，自然的想法是看y-x是否为正
    然而会有溢出的问题，而且只有当x,y异号的时候才会溢出；
    所以本质上是要讨论x,y的符号的四种情况。然而不能用条件语句，所以要进行一些设计。
    这里进行了一个巧妙的设计：dif = ~sign_x + sign_y
    1. x < 0 && y > 0: dif = 0;
    2. x < 0 && y < 0: dif = -1;
    3. x > 0 && y < 0: dif = -2;
    4. x > 0 && y > 0: dif = -1;
    当dif==0时，必然x<=y，则输出1；
    当dif==-1时，x,y同号，则看delta的符号位是否为0即可
    当dif==-2时，不可能x<=y，则输出0
---
## P10 multFiveEighths
### 题目
    return floor(x*5/8)
### 样例
    multFiveEighths(10) = 6
#### 可用操作符：! ~ & ^ | + << >>

#### 操作符最大数量：12

#### 操作符实际使用数量：8

```C
int multFiveEighths(int x) {
  int a = x >> 3;
  int b = x & 7;
  return a + (a << 2) + ((b + (b<<2)) >> 3);
}
```
### 思路
    首先，这里*5会导致溢出，所以要避免一开始就*5
    那么，一开始先/8，然后再*5
    /8之后会得到一个商a，和一个余数b。它们分别*5的结果加起来即可
    对于余数b，它是x的末三位，不存在溢出的情况，所以对它先*5，再/8
---
## P11 bitCount
### 题目
    输出二进制表示中的1的个数
### 样例
    bitCount(7) = 3
#### 可用操作符：! ~ & ^ | + << >>

#### 操作符最大数量：40

#### 操作符实际使用数量：36

```C
int bitCount(int x) {
  int tmp, l1, l2, l4, l8, l16; 
  tmp = (0x55 << 8) + 0x55;
  l1 = (tmp << 16) + tmp; //0x55555555
  tmp = (0x33 << 8) + 0x33;
  l2 = (tmp << 16) + tmp; //0x33333333
  tmp = (0x0f << 8) + 0x0f;
  l4 = (tmp << 16) + tmp; //0x0f0f0f0f
  l8 = (0xff << 16) + 0xff; //0x00ff00ff
  l16 = (0xff << 8) + 0xff; //0x0000ffff

  x = (x & l1) + ((x >> 1) & l1);
  x = (x & l2) + ((x >> 2) & l2);
  x = (x & l4) + ((x >> 4) & l4);
  x = (x & l8) + ((x >> 8) & l8);
  x = (x & l16) + ((x >> 16) & l16);
  return x;
}
```
### 思路
    本题用了分治思想：
    对于1位二进制数来说，1的个数无非就是其本身所表示的1或0。
    利用这个特性，我们可以先两位两位看，在每两位中计算1的个数。
    此时，这两位所代表的含义和原来1位所代表的含义相同。
    接着再4位4位看，8位、16位、最终32位。
---
## P12 greatestBitPos
### 题目
    生成掩码，只保留x的最高位1
### 样例
    greatestBitPos(-2) = -2147483648
#### 可用操作符：! ~ & ^ | + << >>

#### 操作符最大数量：60

#### 操作符实际使用数量：37

```C
int greatestBitPos(int x) {
  int n = 0;
  int minus_one = ~0; //用于生成掩码
  n += ((!!(x&(minus_one<<(n+16)))) << 4);
  n += ((!!(x&(minus_one<<(n+8)))) << 3);
  n += ((!!(x&(minus_one<<(n+4)))) << 2);
  n += ((!!(x&(minus_one<<(n+2)))) << 1);
  n += (!!(x&(minus_one<<(n+1))));
  return (1<<n)&x;
}
```
### 思路
    利用二分法：
    如果x & 0xffff0000 == 0，那么最高位必定在后16位（基准点n+=0）
    否则只用在前16位找即可（基准点n+=16）。
    接着把剩下的16位同上述方法寻找即可
---
## P13 bang
### 题目
    不用！生成逻辑非
### 样例
    bang(0) = 1
#### 可用操作符：~ & ^ | + << >>

#### 操作符最大数量：12

#### 操作符实际使用数量：6

```C
int bang(int x) {
  return ((x >> 31) | ((~x + 1) >> 31)) + 1;
}
```
### 思路
    只用观察0的特性即可：+0 和 -0 符号位相同
    其他数字正负符号位不同
---
## P14 bitReverse
### 题目
    逆序输出位
### 样例
    bitReverse(0x80000004) = 0x20000001
#### 可用操作符：! ~ & ^ | + << >>

#### 操作符最大数量：40

#### 操作符实际使用数量：40

```C
int bitReverse(int x){
  int tmp, l1, l2, l4, l8, l16; 
  tmp = (0x55 << 8) + 0x55;
  l1 = (tmp << 16) + tmp; //0x55555555
  tmp = (0x33 << 8) + 0x33;
  l2 = (tmp << 16) + tmp; //0x33333333
  tmp = (0x0f << 8) + 0x0f;
  l4 = (tmp << 16) + tmp; //0x0f0f0f0f
  l8 = (0xff << 16) + 0xff; //0x00ff00ff
  l16 = (0xff << 8) + 0xff; //0x0000ffff  

  x = ((x&l1)<<1) + ((x>>1)&l1); 
  x = ((x&l2)<<2) + ((x>>2)&l2);
  x = ((x&l4)<<4) + ((x>>4)&l4);
  x = ((x&l8)<<8) + ((x>>8)&l8);
  x = (x<<16) + ((x>>16)&l16);
  return x;
}
```
### 思路
    用二分，思路基本同bitCount
    注意到倒数第二行x<<16不需要写成(x&l16)<<16，可以省一个操作符
---
## P15 mod3
### 题目
    不用% 计算x mod 3
### 样例
    mod3(-100) = -1
#### 可用操作符：! ~ & ^ | + << >>

#### 操作符最大数量：90

#### 操作符实际使用数量：48

```C
int mod3(int x) {
  int sign, y, z, a, b, c, tmp;
  sign = x >> 31;
  x = (x ^ sign) + (~sign + 1); //把x变成绝对值

  tmp = (0xff << 8) + 0xff;
  y = ((x >> 16) & tmp) + (x & tmp);
  y = (y >> 16) + (y & tmp);

  z = ((y >> 8) & 0xff) + (y & 0xff);
  z = (z >> 8) + (z & 0xff);

  a = ((z >> 4) & 0xf) + (z & 0xf);
  a = (a >> 4) + (a & 0xf);

  b = ((a >> 2) & 0x3) + (a & 0x3);
  b = (b >> 2) + (b & 0x3);

  c = b & (b >> 1);
  c = c + (c << 1);

  b = b + (~c + 1);
  return (sign & (~b + 1)) | ((~sign) & b);
}
```
### 思路
    2^n mod 3 == (-1)^n，所以结果就是把每一位(-1)^n相加即可
    所以可以将所有模3的结果叠加到最后一位上，然后处理负数情况即可
---
## P16 float_neg
### 题目
    浮点数的相反数（若是NaN就返回）
#### 可用操作符：所有的整型操作，包括 ||, &&. 以及 if, while

#### 操作符最大数量：10

#### 操作符实际使用数量：5

```C
unsigned float_neg(unsigned uf) {
  unsigned exp = uf & 0x7f800000;
  unsigned frac = uf & 0x007fffff;
  if(exp == 0x7f800000 && frac) return uf;
  return uf ^= 0x80000000;
}
```
### 思路
    判断是否为NaN + 符号位取反
---
## P17 float_i2f
### 题目
    整型换浮点数
#### 可用操作符：所有的整型操作，包括 ||, &&. 以及 if, while

#### 操作符最大数量：40

#### 操作符实际使用数量：30

```C
unsigned float_i2f(int x) {
  int s = x & 0x80000000;
  int n = 30;
  if(!x) return 0;
  if(x == 0x80000000) return 0xcf000000;
  if(s) x = ~x+1;
  while(!(x&(1<<n))) n--; //找最高位的1
  if(n<=23) x <<= (23-n); //需要向左移动到小数部分起始位置
  // 否则要向右移动到小数部分起始位置，然而有舍入
  else{
    //移出的部分：
    // ==0.5: 向偶数舍入
    // >0.5:  向上舍入
    // <0.5:  向下舍入
    x += (1<<(n-24)); // 先直接向上舍入，因为后面再右移所以没关系
    if(x << (55-n)) ;else x &= (0xffffffff<<(n-22));  // 如果移出的位==0.5，要向偶数舍入
    if(x & (1<<n))  ;else n++;  //若向上舍入时最高位产生了进位，加上进位
    x >>= (n-23);
  }
  x=x&0x007fffff;
  n=(n+127)<<23;
  return x | n | s;
}
```
### 思路
    分成三部分：符号、指数、小数部分
    由于要进行右移操作，所以要把x变成非负的
    从左往右找到第一个1，即可求出指数
    要把小数部分移到小数部分开始的位置
    移动有可能会有舍入，要分类讨论即可
---
## P18 float_twice
### 题目
    浮点数的相反数（若是NaN就返回）
#### 可用操作符：所有的整型操作，包括 ||, &&. 以及 if, while

#### 操作符最大数量：30

#### 操作符实际使用数量：12

```C
unsigned float_twice(unsigned uf) {
  int e = (uf&0x7f800000)>>23;
  int s = uf&0x80000000;
  if(e == 0) return (uf<<1)|s;
  if(e == 255) return uf;
  ++e;
  if(e == 255) return 0x7f800000|s; //保证其为INF，不是NaN
  return (uf&0x807fffff)|(e<<23);
}
```
### 思路
    如果是特殊值，直接返回即可
    如果是非规格化数，直接左移1位即可
    如果是规格化数，指数+1
    然后再要判断是否变为了特殊值，如果是，则要保证不是NaN
---
## 实验结果截图
![image-20221001115723628](C:\Users\Life_Dancer\AppData\Roaming\Typora\typora-user-images\image-20221001115723628.png)

![image-20221001115742201](C:\Users\Life_Dancer\AppData\Roaming\Typora\typora-user-images\image-20221001115742201.png)

---
## 参考资料

    https://yezhem.com/index.php/archives/6/
    
    https://xcraft.tech/2020/11/05/ICS/ICS_Lab1/#ICS-Lab1-%E4%BD%8D%E8%BF%90%E7%AE%97
    
    https://wdxtub.com/csapp/thick-csapp-lab-1/2016/04/16/
